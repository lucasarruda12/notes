# Interrupções

Parte do principio de que o processo, imediatamente após entrar na região crítica, desabilita interrupções. Sem interrupções, não há escalonamento de um novo processo

- Potencialmente perigoso: Deixar na mão dos processos a capacidade de decidir se o escalonador efetivamente realizar uma troca de processos

- Não funciona em um ambiente multiprocessado, já que não existe um mecanismo para parar todos os processadores

# variáveis de trava (lock)

Utilizar uma única variável compartilhada, incialmente contendo o valor 0. Então, para acessar a região crítica, o processo realiza um teste sobre essa variável e:
    - Se o valor é 0, significa que ela pode entrar
    - Se o valor é 1, significa que ela não pode entrar

- Apresenta o mesmo problema anterior: caso um processo seja interrompido pelo escalonador durante o teste da variável de lock, a exclusão mútua pode falhar.

### Chaveamento obrigatório

Cada processo recebe um identificador 0 ou 1 e só pode acessar a região crítica quando a variável compartilhada `turn` for igual ao seu identificador.

- Cada processo fica encarregado de chavear a variável compartilhada para deixar o colega entrar

# Solução de Peterson

Antes de usar as variavéis compartilhadas, cada processo chama a função `enter_region`, passando como parametro o numero do seu processo

- Imediatamente antes de sair da regiap critica, o processo chama `leave_region`

# Instrução TSL

O principal problema para a corretude das funçoes até agora é durante a checagem de entrada a região crítica.

Como garantir a tomicidade do mecanismo de trava:

- Criação de uma instrução em linguagem assembly que realize verifique (test) e atualize (set): TSL (Test and Set Lock)

```assembly
enter_region:
    TSL REGISTER.LOCK   | copia lock para o registrador e põe lock em 1
    COMP REGISTER, #0   | lock valia 0?
    JNE enter_region    | se fosse diferente de zero, lock estaria ligado, portante continue no laço de repetição

    RET                 | retorna a quem chamou (entrou na região crítica)

leave_region:
    MOVE LOCK, #0       | coloque 0 em lock
    RET
```

# Soluções de dormir e acordar

Para evitar o uso de espera ocupada, foram propostas primitivas Sleep e Wakeup

- Ao realizar uma chamada sleep, o processo abre mão voluntariamente do processador e não retorna ao estado de pronto.

- Ao executar uma chamada Wakeup, um processo retorna para a lista de prontos um outro processo que estava adormecido.

- Esses mecanismos não são suficientes para garantir exclusão mútua, pela falta de atomicidade no acesso à região crítica.

# Mutex (Mutual Exclusion)

Faz uso do conceito de instruções TSL para garantir atomicidade e primitivas sleep e wakeup

- Primitivas lock e unlock: Similares às variáveis de trava, entretanto garantem atomicidade.
    - Essas variáveis de trava são binárias
    - Sempre que há uma chamada de Lock, existe uma chamada de yield que abre mão do processador

# Semáforos

Implementação mais robustas do que os Mutexes, usando primitivas down e up 

- Down: similar a chamada lock, mas faz uso de uma variável não-binária (decrementando-a)
    - Sempre que um processo executar a chamada Down em um mutex, eu: decremento o valor da variável `e` e verifico se o novo valor é zero. Se for, durmo sem concluir a chamada Down (tudo isso atomicamente)

- Up: Incrementa essa variável.
    - De maneira análoga, uma chamada Up incrementa esse variável e um dos processos adormecidos no meio de uma chamada Down é acordado


