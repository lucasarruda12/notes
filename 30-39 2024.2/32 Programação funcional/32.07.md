# 16 de out de 2024

## Recaptulando tipos novos

Nat, Bool, ListNat

## Head e Tail

> [Sobre desconstrutores] Em geral, se eu penso em chamar head xs, tail xs, pred n: Eu já tô fazendo uma coisa errada. já deveria ter um nome muito bom pro `head xs` (x, inclusive). Precisar chamar isNotNil numa lista sempre que eu quiser chamar as head, tail pra ter certeza que ela não vai explodir o mundo vai me deixar de novo no problema do booleanismo.

```
head :: ListNat -> Nat
head (x : \_) = x
head _        = error "..."
```

```
tail :: ListNat -> ListNat
tail (\_ : xs) = xs
tail _         = error "..."
```

- Faz sentido pensar que os construtores (e não os tipos) tem desconstrutures.
- Faz (mais ainda) sentido esperar que um constutor tenha número de desconstrutores igual à aridade dele.

## OMG polimorfismo hi!!

No lugar de fazer 

```
ìd :: Nat -> Nat
id x = x
```

```
id :: Bool -> Bool
id x = x
```

Posso definir uma infinidade dessas funções com

```
(to each a :: Type)
id :: a -> a
id x = x
```

Expandindo essa ideia, posso definir um infinidade de tipos com

```
data List a
    nil     :: List a
    Cons   :: a -> List a -> List a
```

## List

- Tipos e Kastas 
- GHCI e *

## Typeclasses

Quero definir uma sum pras listas. Não posso definir pra todo tipo a, pode ser que eu não saiba somar em um certo a. Adiciono constraints na minha função.

- O 3 tem tipo `Num a => a`. Ou seja: O 3 tem qualquer tipo a, desde que a cumpra com as restrições de `Num`.
- Posso ter vários constraints em uma função: `Num a, Eq a, Show a => a -> Bool`

### Implementando TypeClasses

```
Show Nat
    show O      = "O"
    show S n    = "S" ++ show n
```
