# JML

## Verificação modular

A verificação em JML (e outras linguagens e ferramentas de verificação dedutiva semelhantes) é modular por método. Ou seja, cada método é verificado por conta própria.

- Somente quando todos os métodos são verificados que o programa pode ser considerado verificado.

- Desde que mantenhamos as mesmas especificações do chamador, podemos verificar o chamador e o chamado independentemente.

- Esse processo é correto quando há chamadas recursivas, desde que seja comprovado que o programa termina.

- A verificação modular diz respeito a "como" os métodos são verificados, e não a "quais" métodos/classes são verificados.

### Chamada de métodos em especificações

Podemos chamar métodos nas especificações, mas existem restrições:

- Expressões nas especificações não devem ter nenhum efeito no programa Java.

- Métodos chamados nas especificações na devem ter nenhum efeito colateral.

- Construtores não podem ser usados nas especificações.

- Quando um método é usado em uma especificação, seu comportamento é determinado por sua especificação, não por sua implementação.

## Múltiplos casos de especificação

JML permite separar a especificação do método em vários casos de especificação, que podem ser considerados comportamentos diferentes

- Cada comportamento é uma sequencia simples de clausulas

- Todo comportamento se aplica por conta própria e deve ser valido por si só

- Se as pré-condições de um comportamento são válidas, então suas pós condições devem ser válidas, independentemente dos outros comportamentos.

## Especificando exceções

- `Signals (E e) P`: se o método terminar com uma exceção `de` tipo `E`, então `P` deve ser satisfeito.

- `signals_only T1, ..., Tn`:
    - Método lança apenas exceções subtipos de `T1, ..., Tn`.
    - No máximo uma clausula por especificação.
    - Padrão `signals_only \nothing` se a clausula for omitida.

### Behaviors

- `public normal_behavior`: Comportamento normal que não lança exceções
- `public exceptional_behavior`: Comportamento do método quando lança uma exceção.

## Variaveis fantasma

É possível e útil, incluir variáveis e cálculos que são apanas para especificação. Isso serve para:

- Controle de informações sobre uma classe que a implementação Java não faz.
- Registrar algum valor ou realizar algum calculo a nível de especificação com a finalidade de verificar a implementação Java.

- Declaramos variáveis com a keyword `ghost`.

- Podem ser declaradas a nível de classe ou método e estão no escopo de especificação.
- `set` é usado para mudar o valor dessas variáveis e pode ser usado com o retorno de métodos puros.

## Abstração de especificação (especificando interfaces)

Precisamos expressar as propriedades em termos de aguams quantiaddes abstratas. Atributos modelo podem ser usados paa descrever as propriedades de uma classe abstrata

### Model fields

Usados somente em especificações para encapsular alguma propriedade de uma classe. Recebem uma implementação escrevendo uma clausula `represents` na classe derivada, conectando-o à implementação concreta.

- Também podem ser usado em uma classe concreta para representar alguma característica que não esta explicitamente presente na classe concreta.

### Datagroup

Um modelfield também é um datagruop; um datagroups autônomo (não associado a um valor abatato) pode ser declarado usando o tipo JMLDataGroup.
